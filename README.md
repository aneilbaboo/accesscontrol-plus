# RBACPlus

Roles-based access control with inheritance and attribute tests.

```js
import RBACPlus from 'rbac-plus';

function userIsResourceOwner({user, resource}) {
  return user.id === resource.ownerId;
}
function userImpersonatesResourceOwner({user, resource}) {
  return user.impersonationId === resource.ownerId;
}
function articleIsPublished({resource}) {
  return resource.state === 'published';
}

const rbac = new RBACPlus();
//
// 4 roles: public, author, admin, superadmin
//
rbac
  .deny('public') // by default, the public cannot use any resource
    .scope('*:*')
  .grant('public')
    .scope('article:read').where(articleIsPublished)
  .grant('author').inherits('public')
    .resource('article')
      .action('create')
        .withConstraint(({user})=>({ ownerId: user.id })) // arguments to include when creating resource
      .action('read') // === .scope('article:read')
        .where(userIsResourceOwner)
      .action('update') // === .scope('article:update')
        .where(userIsResourceOwner)
  .grant('admin').inherits('author')
    .resource('article')
      .action('read').where(userImpersonatesResourceOwner)
  .grant('superadmin').inherits('admin')
    .resource('user')
      .action('*');

//
// The following are objects which are generated by your code
// during a request - users, resources, etc:
//
const user = { id: 1234 }; // determined by request authentication
const draft = { ownerId: 1234, state: 'draft', text: '...' }; // retrieved from db
const published = { ownerId: 1234, state: 'published', text: '...' }; // retrieved from db
const adminUser = { id: 999, impersonationId: 1234 };
const superAdmin = { id: 222 };

async function testPermissions {
  let permission;
  // public can read published articles
  permission = await rbac.can('public', 'article:read', { user: null, resource: published });
  // permission.granted => truthy

  // public can't read draft articles
  permission = await rbac.can('public', 'article:read', { user: null, resource: draft });
  // permission.granted => falsy
  // permission.denied = ['public:article:read:articleIsPublished']

  // author can read their own draft article
  permission = rbac.can('author', 'article:read', { user, resource: draft });
  // permission.granted => truthy

  // auth can update their own article
  permission = rbac.can('user', 'article:update', { user: user, resource: draft });
  // permission.granted => truthy

  // admin cannot update an author's article, even if they are impersonating them
  permission = rbac.can('admin', 'article:update', { user: adminUser, resource: draft});
  // permission.granted => falsy
  // permision.denied = [ 'author:article:update:userIsResourceOwner' ]

  // admin can read a draft article if they are impersonating the author
  permission = rbac.can('admin', 'article:read', { user: adminUser, resource: draft});
  // permission.granted => truthy

  // superadmin can do anything to user resources
  permission = rbac.can('superadmin', 'user:delete', { user: superAdmin, resource: user });
  // permission.granted => truthy
}
```

## API

### RBACPlus

#### constructor
```js
import {RBACPlus, All} from 'rbac-plus';
const rbac = new RBACPlus();
```
or
```js
const rbac = new RBACPlus({
  admin: {
    resources: {
      user: {
        delete: {
          condition: All,
          effect: 'grant'
        }
      }
    }
    inherits: [ 'user' ]
  }
});
```

#### #can
Returns a permission indicating whether the given role can access the scope:
```js
// context is a developer-defined value passed to conditions
// (see Scope #where, #and, #or)
const context = { user: { id: 'the-user-id' } };
rbac.can('admin', 'delete:user', context);
```

#### #grant
Returns a Role object which will grant permissions
```js
rbac.grant('admin') // => Role instance
```

#### #deny
Returns a Role object which will grant permissions
```js
rbac.deny('admin') // => Role instance
```

### Role
Represents a named role.

#### #inherits
Inherit permissions from another role:
```js
role.inherits('public'); // => Role instance
```

#### #resource
Access a resource of a particular role:
```js
role.resource('article'); // => Resource instance
```

#### #scope
Access a scope, a short cut for accessing a resource then accessing an action:
```js
role.scope('article:read'); // same as role.resource('article').action('read')
```

### Resource
A resource object is obtained using the `Role.resource` method

#### #action
```js
resource.action('read'); // => Scope
```

### Scope
Represents a specific permission, and enables setting conditions and constrains on the permission.

#### #where
Sets one or more tests which must all pass for the permission to be granted. This method is equivalent to `scope.and`, except for the name generated in the `permission.grant` and `permission.deny`:

```js
function async ownsResource({ user, request }) {
  const resource = await MyResource.loadFromDB({ id: request.params.id });
  return resource.id === user.id;
}
scope.where(ownsResource); // => Scope
```

#### #and
Grants permission for the scope if all of the tests return truthy values:
```js
scope.and(test1, test2, test3...);
```

#### #or
Grants permission for the scope if any of the tests return a truthy value:
```js
scope.or(test1, test2, test3...);
```

#### #withConstraint
Add a function which returns a constraint useful to the developer for passing to a function that accesses a resource:
```js
rbac.grant('user').scope('article:create')
  .withConstraint(({user})=>({ ownerId: user.id})); // => Scope
...
let permission = await rbac.can('user', 'article:create', { user: { id: 123 }});
if (permission.granted) {
  await Article.create(permission.constraint); // { ownerId: 123 }
}
```
